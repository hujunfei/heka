
AMQPInput
=========

Connects to a remote AMQP broker (RabbitMQ) and retrieves messages from the
specified queue. As AMQP is dynamically programmable, the broker topology
needs to be specified in the plugin configuration.

Config:

- URL (string):
    An AMQP connection string formatted per the `RabbitMQ URI Spec
    <http://www.rabbitmq.com/uri-spec.html>`_.
- Exchange (string):
    AMQP exchange name
- ExchangeType (string):
    AMQP exchange type (`fanout`, `direct`, `topic`, or `headers`).
- ExchangeDurability (bool):
    Whether the exchange should be configured as a durable exchange. Defaults
    to non-durable.
- ExchangeAutoDelete (bool):
    Whether the exchange is deleted when all queues have finished and there
    is no publishing. Defaults to auto-delete.
- RoutingKey (string):
    The message routing key used to bind the queue to the exchange. Defaults
    to empty string.
- PrefetchCount (int):
    How many messages to fetch at once before message acks are sent. See
    `RabbitMQ performance measurements <http://www.rabbitmq.com/blog/2012/04/25/rabbitmq-performance-measurements-part-2/>`_
    for help in tuning this number. Defaults to 2.
- Queue (string):
    Name of the queue to consume from, an empty string will have the broker
    generate a name for the queue. Defaults to empty string.
- QueueDurability (bool):
    Whether the queue is durable or not. Defaults to non-durable.
- QueueExclusive (bool):
    Whether the queue is exclusive (only one consumer allowed) or not.
    Defaults to non-exclusive.
- QueueAutoDelete (bool):
    Whether the queue is deleted when the last consumer un-subscribes.
    Defaults to auto-delete.
- QueueTTL (int):
    Allows ability to specify TTL in milliseconds on Queue declaration for expiring messages.
    Defaults to undefined/infinite.
- Decoder (string):
    Decoder name used to transform a raw message body into a structured hekad
    message. Must be a decoder appropriate for the messages that come in from
    the exchange. If accepting messages that have been generated by an
    AMQPOutput in another Heka process then this should be a
    :ref:`config_protobuf_decoder` instance.

Since many of these parameters have sane defaults, a minimal configuration to
consume serialized messages would look like:

.. code-block:: ini

    [AMQPInput]
    url = "amqp://guest:guest@rabbitmq/"
    exchange = "testout"
    exchangeType = "fanout"

Or you might use a PayloadRegexDecoder to parse OSX syslog messages with the
following:

.. code-block:: ini

    [AMQPInput]
    url = "amqp://guest:guest@rabbitmq/"
    exchange = "testout"
    exchangeType = "fanout"
    decoder = "logparser"

    [logparser]
    type = "MultiDecoder"
    order = ["logline", "leftovers"]

      [logparser.subs.logline]
      type = "PayloadRegexDecoder"
      MatchRegex = '\w+ \d+ \d+:\d+:\d+ \S+ (?P<Reporter>[^\[]+)\[(?P<Pid>\d+)](?P<Sandbox>[^:]+)?: (?P Remaining>.*)'

        [logparser.subs.logline.MessageFields]
        Type = "amqplogline"
        Hostname = "myhost"
        Reporter = "%Reporter%"
        Remaining = "%Remaining%"
        Logger = "%Logger%"
        Payload = "%Remaining%"

      [leftovers]
      type = "PayloadRegexDecoder"
      MatchRegex = '.*'

        [leftovers.MessageFields]
        Type = "drop"
        Payload = ""
